package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.82

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/Kenfoxfire/Gear-Core-app/internal/domain"
	"github.com/Kenfoxfire/Gear-Core-app/internal/graph/model"
	httpx "github.com/Kenfoxfire/Gear-Core-app/internal/http"
)

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	u, tok, err := r.Auth.SignupViewer(ctx, email, password)
	if err != nil {
		return nil, err
	}
	return &model.AuthPayload{Token: tok, User: mapUser(u)}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	u, tok, err := r.Auth.Login(ctx, email, password)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{Token: tok, User: mapUser(u)}, nil
}

// CreateVehicle is the resolver for the createVehicle field.
func (r *mutationResolver) CreateVehicle(ctx context.Context, input model.VehicleInput) (*model.Vehicle, error) {
	_, role, ok := httpx.UserFrom(ctx)
	if !ok || role == "" || role == "Viewer" {
		return nil, httpx.ErrForbidden
	}
	v, _ := r.Repos.GetVehicleByVin(ctx, input.Vin)
	if v != nil {
		return nil, fmt.Errorf("vehicle with vin %s already exists", input.Vin)
	}

	v = &domain.Vehicle{
		VIN: input.Vin, Name: input.Name, ModelCode: input.ModelCode,
		TractionType: string(input.TractionType), ReleaseYear: int(input.ReleaseYear),
		BatchNumber: input.BatchNumber, Color: ptrStr(input.Color), Mileage: ptrInt32ToInt(input.Mileage, 0),
		Status: string(*input.Status),
	}
	v, err := r.Repos.CreateVehicle(ctx, v)
	if err != nil {
		return nil, err
	}
	return mapVehicle(v), nil
}

// UpdateVehicle is the resolver for the updateVehicle field.
func (r *mutationResolver) UpdateVehicle(ctx context.Context, id string, input model.VehicleUpdateInput) (*model.Vehicle, error) {
	v, err := r.Repos.GetVehicleByID(ctx, parseID(id))
	if err != nil {
		if err.Error() == "pg: no rows in result set" {
			return nil, fmt.Errorf("vehicle with id %s not found", id)
		}
		return nil, err
	}

	if input.Name != nil {
		v.Name = *input.Name
	}
	if input.ModelCode != nil {
		v.ModelCode = *input.ModelCode
	}
	if input.TractionType != nil {
		v.TractionType = string(*input.TractionType)
	}
	if input.ReleaseYear != nil {
		v.ReleaseYear = int(*input.ReleaseYear)
	}
	if input.BatchNumber != nil {
		v.BatchNumber = *input.BatchNumber
	}
	if input.Color != nil {
		v.Color = *input.Color
	}
	if input.Mileage != nil {
		v.Mileage = ptrInt32ToInt(input.Mileage, 0)
	}
	if input.Status != nil {
		v.Status = string(*input.Status)
	}
	updatedVehicle, err := r.Repos.UpdateVehicle(ctx, v)
	if err != nil {
		return nil, err
	}
	return mapVehicle(updatedVehicle), nil
}

// DeleteVehicle is the resolver for the deleteVehicle field.
func (r *mutationResolver) DeleteVehicle(ctx context.Context, id string) (bool, error) {
	_, role, ok := httpx.UserFrom(ctx)
	if !ok || role == "" || role != "Admin" {
		return false, httpx.ErrForbidden
	}

	v, err := r.Repos.GetVehicleByID(ctx, parseID(id))

	if err != nil || v.ID == 0 {
		return false, fmt.Errorf("vehicle with id %s not found", id)
	}
	err = r.Repos.DeleteVehicle(ctx, v.ID)
	if err != nil {
		return false, err
	}
	return true, nil
}

// CreateMovement is the resolver for the createMovement field.
func (r *mutationResolver) CreateMovement(ctx context.Context, input model.MovementInput) (*model.Movement, error) {
	userID, role, ok := httpx.UserFrom(ctx)
	if !ok || role == "" || role == "Viewer" {
		return nil, httpx.ErrForbidden
	}

	v, err := r.Repos.GetVehicleByID(ctx, parseID(input.VehicleID))
	if err != nil || v.ID == 0 {
		return nil, fmt.Errorf("vehicle with id %s not found", input.VehicleID)
	}

	var metadata map[string]any
	if input.Metadata != nil {
		if err := json.Unmarshal([]byte(*input.Metadata), &metadata); err != nil {
			return nil, fmt.Errorf("invalid metadata: %w", err)
		}
	}

	m, err := r.Repos.CreateMovement(ctx, &domain.Movement{
		VehicleID:   v.ID,
		Vehicle:     v,
		Type:        string(input.Type),
		Description: *input.Description,
		Metadata:    metadata,
		CreatedBy:   userID,
		CreatedAt:   time.Now(),
		OccurredAt:  input.OccurredAt,
	})
	if err != nil {
		return nil, err
	}
	return mapMovement(m), nil
}

// ChangeUserRole is the resolver for the changeUserRole field.
func (r *mutationResolver) ChangeUserRole(ctx context.Context, userID string, newRole string) (bool, error) {
	if err := httpx.RequireAdmin(ctx); err != nil {
		return false, err
	}
	if err := r.Auth.ChangeUserRole(ctx, "Admin", parseID(userID), newRole); err != nil {
		return false, err
	}
	return true, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	uid, role, asserted := httpx.UserFrom(ctx)
	if role == "" {
		return nil, fmt.Errorf("error role not found")
	}
	if !asserted {
		return nil, fmt.Errorf("error asserting value")
	}

	user, err := r.Repos.GetUserByUID(ctx, uid)
	if err != nil {
		if err.Error() == "pg: no rows in result set" {
			return nil, fmt.Errorf("user with id %d not found", uid)
		}
		return nil, err
	}
	return mapUser(user), nil
}

// Vehicle is the resolver for the vehicle field.
func (r *queryResolver) Vehicle(ctx context.Context, id string) (*model.Vehicle, error) {
	_, role, ok := httpx.UserFrom(ctx)
	if !ok || role == "" {
		return nil, httpx.ErrForbidden
	}
	v, err := r.Repos.GetVehicleByID(ctx, parseID(id))
	if err != nil {
		if err.Error() == "pg: no rows in result set" {
			return nil, fmt.Errorf("vehicle with id %s not found", id)
		}
		return nil, err
	}
	return mapVehicle(v), nil
}

// Vehicles is the resolver for the vehicles field.
func (r *queryResolver) Vehicles(ctx context.Context, limit *int32, offset *int32) ([]*model.Vehicle, error) {
	_, role, ok := httpx.UserFrom(ctx)
	if !ok || role == "" {
		return nil, httpx.ErrForbidden
	}
	vs := []*model.Vehicle{}
	vehicles, err := r.Repos.ListVehicles(ctx, ptrInt32ToInt(limit, 100), ptrInt32ToInt(offset, 0))
	if err != nil {
		return nil, err
	}
	for i := range vehicles {
		vs = append(vs, mapVehicle(vehicles[i]))
	}
	return vs, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int32, offset *int32) ([]*model.User, error) {
	if err := httpx.RequireAdmin(ctx); err != nil {
		return nil, err
	}

	users := []*model.User{}
	items, err := r.Repos.ListUsers(ctx, ptrInt32ToInt(limit, 50), ptrInt32ToInt(offset, 0))
	if err != nil {
		return nil, err
	}
	for i := range items {
		users = append(users, mapUser(items[i]))
	}
	return users, nil
}

// MovementReport is the resolver for the movementReport field.
func (r *queryResolver) MovementReport(ctx context.Context, from time.Time, to time.Time) ([]*model.MovementReportRow, error) {
	reportResult, err := r.Repos.MovementReport(ctx, from, to)
	if err != nil {
		return nil, err
	}
	return mapReport(reportResult), nil
}

// Movements is the resolver for the movements field.
func (r *vehicleResolver) Movements(ctx context.Context, obj *model.Vehicle, limit *int32, offset *int32) ([]*model.Movement, error) {
	if _, role, ok := httpx.UserFrom(ctx); !ok || role == "" {
		return nil, httpx.ErrForbidden
	}

	records, err := r.Repos.ListMovementsByVehicle(ctx, parseID(obj.ID), ptrInt32ToInt(limit, 20), ptrInt32ToInt(offset, 0))
	if err != nil {
		return nil, err
	}

	result := make([]*model.Movement, 0, len(records))
	for _, movement := range records {
		result = append(result, mapMovement(movement))
	}
	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Vehicle returns VehicleResolver implementation.
func (r *Resolver) Vehicle() VehicleResolver { return &vehicleResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type vehicleResolver struct{ *Resolver }
