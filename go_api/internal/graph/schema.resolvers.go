package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.82

import (
	"context"
	"fmt"
	"strconv"
	"time"

	"github.com/Kenfoxfire/Gear-Core-app/internal/domain"
	"github.com/Kenfoxfire/Gear-Core-app/internal/graph/model"
	httpx "github.com/Kenfoxfire/Gear-Core-app/internal/http"
)

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	u, tok, err := r.Auth.SignupViewer(ctx, email, password)
	if err != nil {
		return nil, err
	}
	return &model.AuthPayload{Token: tok, User: mapUser(u)}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	// TODO testy
	u, tok, err := r.Auth.Login(ctx, email, password)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{Token: tok, User: mapUser(u)}, nil
}

// CreateVehicle is the resolver for the createVehicle field.
func (r *mutationResolver) CreateVehicle(ctx context.Context, input model.VehicleInput) (*model.Vehicle, error) {
	_, role, ok := httpx.UserFrom(ctx)
	if !ok || role == "" || role == "Viewer" {
		return nil, httpx.ErrForbidden
	}
	v, _ := r.Repos.GetVehicleByVin(ctx, input.Vin)
	if v.ID != 0 {
		return nil, fmt.Errorf("vehicle with vin %s already exists", input.Vin)
	}

	v = &domain.Vehicle{
		VIN: input.Vin, Name: input.Name, ModelCode: input.ModelCode,
		TractionType: string(input.TractionType), ReleaseYear: int(input.ReleaseYear),
		BatchNumber: input.BatchNumber, Color: ptrStr(input.Color), Mileage: ptrInt32ToInt(input.Mileage, 0),
		Status: string(*input.Status),
	}
	v, err := r.Repos.CreateVehicle(ctx, v)
	if err != nil {
		return nil, err
	}
	return mapVehicle(v), nil
}

// UpdateVehicle is the resolver for the updateVehicle field.
func (r *mutationResolver) UpdateVehicle(ctx context.Context, id string, input model.VehicleUpdateInput) (*model.Vehicle, error) {

	v, err := r.Repos.GetVehicleByID(ctx, parseID(id))
	if err != nil {
		return nil, err
	}

	if input.Name != nil {
		v.Name = *input.Name
	}
	if input.ModelCode != nil {
		v.ModelCode = *input.ModelCode
	}
	if input.TractionType != nil {
		v.TractionType = string(*input.TractionType)
	}
	if input.ReleaseYear != nil {
		v.ReleaseYear = int(*input.ReleaseYear)
	}
	if input.BatchNumber != nil {
		v.BatchNumber = *input.BatchNumber
	}
	if input.Color != nil {
		v.Color = *input.Color
	}
	if input.Mileage != nil {
		v.Mileage = ptrInt32ToInt(input.Mileage, 0)
	}
	if input.Status != nil {
		v.Status = string(*input.Status)
	}
	updatedVehicle, err := r.Repos.UpdateVehicle(ctx, v)
	if err != nil {
		return nil, err
	}
	return mapVehicle(updatedVehicle), nil
}

// DeleteVehicle is the resolver for the deleteVehicle field.
func (r *mutationResolver) DeleteVehicle(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteVehicle - deleteVehicle"))
}

// CreateMovement is the resolver for the createMovement field.
func (r *mutationResolver) CreateMovement(ctx context.Context, input model.MovementInput) (*model.Movement, error) {
	panic(fmt.Errorf("not implemented: CreateMovement - createMovement"))
}

// ChangeUserRole is the resolver for the changeUserRole field.
func (r *mutationResolver) ChangeUserRole(ctx context.Context, userID string, newRole string) (bool, error) {
	if err := httpx.RequireAdmin(ctx); err != nil {
		return false, err
	}
	if err := r.Auth.ChangeUserRole(ctx, "Admin", parseID(userID), newRole); err != nil {
		return false, err
	}
	return true, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	uid, role, asserted := httpx.UserFrom(ctx)
	if role == "" {
		return nil, fmt.Errorf("error role not found")
	}
	if !asserted {
		return nil, fmt.Errorf("error asserting value")
	}

	user, err := r.Repos.GetUserByUID(ctx, uid)
	if err != nil {
		return nil, err
	}
	return mapUser(user), nil
}

// Vehicle is the resolver for the vehicle field.
func (r *queryResolver) Vehicle(ctx context.Context, id string) (*model.Vehicle, error) {
	panic(fmt.Errorf("not implemented: Vehicle - vehicle"))
}

// Vehicles is the resolver for the vehicles field.
func (r *queryResolver) Vehicles(ctx context.Context, limit *int32, offset *int32) ([]*model.Vehicle, error) {
	panic(fmt.Errorf("not implemented: Vehicles - vehicles"))
}

// MovementReport is the resolver for the movementReport field.
func (r *queryResolver) MovementReport(ctx context.Context, from time.Time, to time.Time) ([]*model.MovementReportRow, error) {

	reportResult, err := r.Repos.MovementReport(ctx, from, to)
	if err != nil {
		return nil, err
	}
	return mapReport(reportResult), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

func mapUser(u *domain.User) *model.User {
	var gqlRole *model.Role
	if u.Role != nil {
		gqlRole = &model.Role{
			ID:        strconv.FormatInt(u.Role.ID, 10),
			Name:      u.Role.Name,
			CreatedAt: u.Role.CreatedAt,
		}
	}
	return &model.User{
		ID:        strconv.FormatInt(u.ID, 10),
		Email:     u.Email,
		Role:      gqlRole,
		CreatedAt: u.CreatedAt,
	}
}
func mapReport(rows []domain.MovementReportRow) []*model.MovementReportRow {
	mapped := make([]*model.MovementReportRow, 0, len(rows))
	for i := range rows {
		r := rows[i]
		mapped = append(mapped, &model.MovementReportRow{
			Type:  model.MovementType(r.Type),
			Count: int32(r.Count),
		})
	}
	return mapped
}

func mapVehicle(v *domain.Vehicle) *model.Vehicle {
	return &model.Vehicle{
		ID: idStr(v.ID), Vin: v.VIN, Name: v.Name, ModelCode: v.ModelCode,
		TractionType: model.TractionType(v.TractionType), ReleaseYear: int32(v.ReleaseYear),
		BatchNumber: v.BatchNumber, Color: strToPtr(v.Color), Mileage: int32(v.Mileage),
		Status: model.VehicleStatus(v.Status), CreatedAt: v.CreatedAt, UpdatedAt: v.UpdatedAt,
	}
}
